{"version":3,"sources":["webpack:///./src/texts/projects/personal_site/blogs/recursive_navbar.md"],"names":[],"mappings":"gHAAA,OAAe","file":"js/chunk-2d0c7ab0.fb0f4a6a.js","sourcesContent":["export default \"---\\n  name: \\\"Recursive Navbar\\\"\\n  date: \\\"01/01/01\\\"\\n  tags: [\\\"Vue.js\\\", \\\"UX/UI\\\", \\\"Recursion\\\"]\\n---\\n\\n# Recursive Tree Navbar in Vue\\n\\nHow to achieve this website's navbar, which is designed to resemble a file system tree and is implemented recursively.\\n\\n## Note\\n\\nThough the tutorial below is valid and much of what was implemented in it remains on the live site, due to issues with mouseover events on mobile browsers such as Safari, I opted for use of click events and scroll events instead.\\n\\n## Intro\\n\\nA website NavBar, serving as a directory of url links, is particularly disposed to internal representation as a tree when nesting occurs (ie. there is a parent-child relationship between the links). Designing the NavBar for my personal/portfolio website: [vinceniko.github.io](https://vinceniko.github.io), I wanted it to be extensible and scalable for an arbitrary number of nested links, and centralized such that the router config would determine the state of the NavBar (thus preventing config duplication with minor alterations across the two components). Also, designing the NavBar to visually resemble a tree would fit the generally terminal styled theme of the website. Given that trees lend themselves in particular to recursive implementations, I decided to implement the NavBar as such. This design would have to fit within the programming paradigm dictated by Vue’s templating and component based standard and as such, this article provides a description of how to achieve a recursive Vue NavBar component.\\n\\nNote: This article assumes some familiarity with Vue’s general principles and the syntax for the web pack module build system.\\n\\n## Recursion in Components\\n\\nThe first and most obvious question that comes up when designing a recursive component in Vue is: is it possible to even create recursive components in Vue? Generally, when a component should be used within the template of another, it must first be registered in the component’s `components` property. But, how would one register `self` as a component? Thankfully, Vue accounts for this with the component `name` property which can then be used as any registered prop would be—-allowing the name of the recursive component to be used as the component’s tag name.\\n\\n```html\\n<template>\\n <RecurComponent></RecurComponent>\\n</template>\\n\\n<script>\\n// recursive component definition\\nexport default {\\n  name: 'RecurComponent',\\n // ...\\n}\\n</script>\\n```\\n\\n## Passing Data Between Components\\n\\nVue components provide mechanisms for passing data from parents to children and vice-versa—`props` and `events` respectively. This is necessary for the recursive NavBar.  \\n\\n### Props\\n\\nArguments are passed to child components with the `props` property. The syntax is similar to declaring `data` in the component, but allows an object to be passed in with its own useful properties (such as type checking and default values). Props are passed to the child using the Vue template binding directive `:prop=\\\"parent_data\\\"` and they can be referenced within the child component as data is: `this.prop` (where `prop` is the property name). Read more about `props` here [vuejs.org/v2/guide/components-props.html](https://vuejs.org/v2/guide/components-props.html):\\n\\nChild Component defining the prop:\\n\\n```javascript\\nexport default {\\n props: [\\n  prop: { type: Number, default: return 0; }\\n ]\\n // ...\\n}\\n```\\n\\nParent Component passing parent_data to the prop:\\n\\n```html\\n<template>\\n  <child :prop=\\\"parent_data\\\"></child>\\n</template>\\n\\n<script>\\nexport default {\\n  data() {\\n    return {\\n      parent_data: 1,\\n    }\\n  }\\n}\\n</script>\\n```\\n\\n### Events\\n\\n`Events` are emitted by child components and are handled by parent components. `Events` are identified with a unique name and can include a payload which can be passed to a method in the parent. An event is created by accessing the Vue instance method `$emit` and is handled in the parent template using the the `v-on` template directive or `@`:\\n\\nChild component emitting the `child_created` event upon creation with a payload of `1`:\\n\\n```javascript\\n// child component\\nexport default {\\n created() {\\n  this.$emit(‘child_created’, 1) // child created is the event name and 1 is the payload\\n }\\n  // ...\\n}\\n```\\n\\nParent event handling the event (note: to pass on the payload to a method, do not call it in the binding, just use its name):\\n\\n```html\\n<template>\\n <child @child_created:”exec”></child>\\n</template>\\n\\n<script>\\nexport default {\\n methods: {\\n  exec(payload) {\\n   // ...\\n  }\\n }\\n // ...\\n}\\n</script>\\n```\\n\\n## Designing the Recursive NavBar\\n\\nNow that we know how to create recursive components and pass data between them, we can begin designing the NavBar.\\n\\n### Router Config as a Tree\\n\\nRecursion, a function defined in terms of itself, lends itself to tree implementations since a set of descendants of any given node in the tree (a sub tree) can be defined as a tree. This principle can be applied to the Vue Router config given that child routes can be assigned to route objects as such:\\n\\n```javascript\\n// router.js\\nexport default new Router({\\n name: ‘root’,\\n // ...\\n children: [{\\n   name: ‘child 1’,\\n   // ...\\n   children: [{\\n    name: ‘grand child 1’\\n                // ...\\n            }]\\n        }, {\\n   name: ‘child 2’, // sibling to child 1\\n   // ...\\n  }\\n ]\\n})\\n```\\n\\nWhen the NavBar is first created in Vue, the router config will be passed in as the basis for its tree structure using: `this.$router.options.routes`.\\n\\n### The RecurNav Component\\n\\nThe RecurNav component‘s purpose is much like any other recursive function helper—-it begins recursion and calls on the first level of RecurLink Components (described further on). The RecurNav also defines the outer container that holds all the RecurLinks in the NavBar.\\n\\n### The RecurLink Component\\n\\nThe RecurLink component is where the majority of the recursive logic must be placed. A RecurLink represents one link in the NavBar which will redirect a user to a different route.\\n\\nNote: A lot of the code in the sections below builds upon code in the preceding sections but may omit details from the preceding sections if they aren't relevant to the section being discussed.\\n\\n#### Basic Template Structure\\n\\n```html\\n<template>\\n  <div>\\n    <router-link class=\\\"parent\\\" :to=\\\"name\\\">{{name}}</router-link>\\n\\n    <div class=\\\"children\\\"\\n    v-if=\\\"children !== undefined\\\">\\n    <!--@event_from_child and :prop_to_child are placeholders-->\\n      <RecurLink\\n      v-for=\\\"child in children\\\" :key=\\\"child.name\\\"\\n      @event_from_child=\\\"handle_child\\\"\\n      :prop_to_child=\\\"prop\\\">\\n      </RecurLink>\\n    </div>\\n  </div>\\n</template>\\n```\\n\\nEssentially, each parent contains its children. The `v-for` directive recursively traverses through a link's children and renders them as RecurLinks. Notice that the RecurLink tag is the recursive call. The base case that ends recursion for each branch is `v-if=\\\"children !== undefined` which conditionally renders the child RouteLinks.\\n\\nNow that we know how to render the routes, we can define when they should be shown or hidden.\\n\\n#### Properties and State\\n\\n##### Passing the Router Config\\n\\nThe routes defined in the Vue global instance router config determine certain members of the NavBar tree structure (the route name and child routes), and have to be passed into each component using the `path_obj` prop:\\n\\n```html\\n<template>\\n  <div>\\n    <router-link class=\\\"parent\\\"\\n    :to=\\\"{name: path_obj.name}\\\">{{path_obj.name}}</router-link>\\n\\n    <div class=\\\"children\\\"\\n    v-if=\\\"path_obj.children !== undefined\\\">\\n      <RecurLink\\n      v-for=\\\"child in path_obj.children\\\" :key=\\\"child.name\\\"\\n      :path_obj=\\\"child\\\">\\n      </RecurLink>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'RecurLink',\\n  props: {\\n    path_obj: Object,\\n    // ...\\n  }\\n  // ...\\n}\\n</script>\\n```\\n\\nUsing the `router-link` component in the Vue Router package allows us to travel `:to` a route (including by using its `name`). Now clicking on a link show allow the user to travel to particular routes defined in the router config!\\n\\nNote: And this is a big one. Using the router config as a central source for state for both the NavBar and Router component has its advantages, but also interferes with an intention of the Vue Router design. Nesting routes using `children` in the route config necessitates the use of the `router-view` component to render route components (read more here: [router.vuejs.org/api/#router-view](https://router.vuejs.org/api/#router-view)). However, we won't want to render both the parent and the child in the same view (which is the intention of nesting routes using `children` in the router config). Take, for example, a project page with an article about the page defined as its children. Though nesting routes makes sense for the NavBar config, it doesn't make as much sense when using `router-view`--the article page shouldn't be rendered within the project page (in this case they are separate pages). However, there is a work around. Only render the parent route when it matches the current route:\\n\\n```html\\n<template>\\n  <div>\\n     <Project v-if=\\\"$route.name === 'Project'\\\"><Project></Project></Project>\\n    <!--When route matches a project component (child rendered in router-view below), do not render project component (parent above)-->\\n    <router-view></router-view>\\n  </div>\\n</template>\\n\\n```\\n\\nNow that we know how to create the links and have them route appropriately, we can discuss when they should be shown (for brevity, simplicity, and ux).\\n\\n##### Conditional Rendering Properties\\n\\nThe **requirements** for conditionally rendering (more on conditional rendering here: [vuejs.org/v2/guide/conditional.html](https://vuejs.org/v2/guide/conditional.html)) the NavBar links, ie. when to show links, are as follows:\\n\\n1. All links that aren’t the selected link or its ancestors would be hidden by default.\\n2. Mousing over, or \\\"hovering\\\" over, a shown link would reveal its children and its siblings.\\n3. A selected link (the current route) would be highlighted.\\n4. An edit on point 1: links in the first level of the tree would be shown by default.\\n\\nThis is the default state of my site’s NavBar, which shows the selected link highlighted and the 1st level shown by default:\\n\\n![default_view](/assets/projects/personal_site/recursive_navbar/default_view.jpg)\\n\\nGiven the requirements provided in the above list, there are several states (most expressed as booleans) that would cause a link to be shown. They can be divided into the `data` and `props` properties depending on whether their state will be modified by a child or a parent respectively:\\n\\n```html\\n<template>\\n  <div>\\n    <router-link class=\\\"parent\\\"\\n    v-show=\\\"displayed()\\\"></router-link>\\n\\n    <div class=\\\"children\\\"\\n    v-if=\\\"children !== undefined\\\">\\n      <RecurLink\\n      v-for=\\\"child in path_obj.children\\\" :key=\\\"child.name\\\"\\n      @event_from_child=\\\"handle_child\\\"\\n      :prop_to_child=\\\"prop\\\">\\n      </RecurLink>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'RecurLink',\\n  props: {\\n    show_as_child: {type: Boolean, default: false}, // child of hovered link or sibling of hovered link\\n    level: {type: Number, default: -1},\\n    // ...\\n  },\\n  data() {\\n    return {\\n      selected: false, // current route\\n      hover: false, // mouseover\\n      ancestor: false, // ancestor of a selected link\\n    }\\n  },\\n  // Then to determine whether or not the link would be displayed:\\n  methods: {\\n    displayed() {\\n      // this.level == 1 displays first level always (since root component is at level 0)\\n      return this.level == 1 || this.selected || this.hover || this.ancestor || this.show_as_child\\n    },\\n  }\\n  // ...\\n}\\n</script>\\n```\\n\\nIn the above code, the `v-show` attribute assigned in the parent calls `displayed` to check whether the link should be displayed or not.\\n\\nWe can also use these states to apply styles conditionally (see more here: [vuejs.org/v2/guide/class-and-style.html](https://vuejs.org/v2/guide/class-and-style.html)):\\n\\n```html\\n<template>\\n  <div>\\n    <router-link class=\\\"parent\\\"\\n    v-show=\\\"displayed()\\\"></router-link>\\n\\n    <div :class=\\\"selected_class()\\\"\\n    class=\\\"children\\\">\\n      <RecurLink\\n      v-for=\\\"child in path_obj.children\\\" :key=\\\"child.name\\\"\\n      </RecurLink>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  methods: {\\n    selected_class() {\\n      // this.level !== 0 because the style is applied to the next level elements\\n      if (this.displayed() && this.level !== 0) {\\n        return 'bordered-cell'\\n      } else {\\n        return ''\\n      }\\n    }\\n  },\\n  // ...\\n}\\n</script>\\n\\n<style>\\n.cell {\\n  text-align: center;\\n}\\n.padded-cell {\\n  padding-left: 3%;\\n  padding-right: 3%;\\n}\\n.bordered-cell {\\n  border-left: 1px solid $main-sec-color;\\n  margin-right: -1rem;\\n  padding-right: 1rem;\\n}\\n</style>\\n```\\n\\n#### Passing State\\n\\n`Props` and `events` will be used to pass state between components because recursive calls heavily leverage parameters to change state. We must handle points 1 (showing ancestors of the selected link) and 2 (showing children and siblings of a hovered link) in the requirements.\\n\\n##### Showing Ancestors\\n\\nThe `ancestor` condition has to be marked true for all ancestors of the selected link. `Events` have to be used since the state change propagates up the component hierarchy.\\n\\n```html\\n<template>\\n  <div>\\n    <router-link class=\\\"parent\\\"></router-link>\\n\\n    <div class=\\\"children\\\">\\n      <RecurLink\\n      v-for=\\\"child in path_obj.children\\\" :key=\\\"child.name\\\"\\n      @show_ancestors=\\\"show_ancestors()\\\"\\n      </RecurLink>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  methods: {\\n    // display all ancestors\\n    show_ancestors() {\\n      this.ancestor = true\\n      this.$emit('show_ancestors')\\n    },\\n  },\\n  // ...\\n}\\n</script>\\n```\\n\\nAncestors are marked when the selected route gets created using the `created` lifecycle hook (more on lifecycle hooks: [vuejs.org/v2/guide/instance.html#Instance-Lifecycle-Hooks](https://vuejs.org/v2/guide/instance.html#Instance-Lifecycle-Hooks)):\\n\\n```js\\nexport default {\\n  created() { // page reload\\n    this.select_from_path(true)\\n  },\\n  methods: {\\n    select_from_path(show_ancestors) {\\n      if (this.$route.name == this.path_obj.name) {\\n        this.selected = true\\n        if (show_ancestors) this.$emit('show_ancestors')\\n      } else {\\n        this.selected = false\\n      }\\n    },\\n    // ...\\n  }\\n  // ...\\n}\\n```\\n\\n##### Showing Children\\n\\nShowing children uses the `show_as_child` prop and occurs when a user hovers over a link:\\n\\n```html\\n<template>\\n  <div>\\n    <router-link class=\\\"parent\\\"\\n    @mouseover=\\\"hover = true\\\"></router-link>\\n\\n    <div v-if=\\\"children !== undefined\\\">\\n      <RecurLink\\n      v-for=\\\"child in path_obj.children\\\" :key=\\\"child.name\\\"\\n      :show_as_child=\\\"hover\\\"\\n      </RecurLink>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  props: {\\n    show_as_child: {type: Boolean, default: false}, // child of hovered link or sibling of hovered link\\n    // ...\\n  },\\n  data() {\\n    return {\\n      hover: false, // arg for show_as_child prop\\n      // ...\\n    }\\n  }\\n}\\n</script>\\n```\\n\\n`Hover` gets passed to the `show_as_child` prop indicating that the link that is being hovered over should display its `children`.\\n\\n### Hiding Links\\n\\nWe have discussed how to show links and when to show links (conditionally), but here we will discuss how and when to hide links.\\n\\nAll links that are not shown by default, as described in the preceding section, will be hidden when the user's cursor leaves the NavBar container (hover exit).\\n\\nThe reason I opted for a hover exit on the NavBar container instead for each item was because the latter caused issues with collapsing items instantaneously, shifting link positions, and confusing the user on where to hover (to implement this I recommend some kind of timeout on hiding links and an opacity transition). The chosen approach also allows the reset (explained below) to be propagated from the root node, which is simple.\\n\\n#### Hover Exit\\n\\nTo hide a link, it must be reset to one of the initial states described in the aforementioned section. Basically, if it is not selected or an ancestor of a selected link, then it must be hidden:\\n\\n```js\\nexport default {\\n  methods: {\\n    reset_state() {\\n      // reset state\\n      this.hover = false\\n      this.ancestor = false\\n\\n      this.select_from_path(true)\\n    },\\n    // ...\\n  }\\n  // ...\\n}\\n```\\n\\n`reset_state` sets all the data properties besides `selected` to false and calls `select_from_path` which checks whether or not the route matches the link and then sets `selected` accordingly.\\n\\nSo whenever a user hover exits the NavBar container, the state of each link is reset to the default state and then `select_from_path` is called and if the route is matched to the current url path, it is marked as selected and ancestors are marked upwards from that link (essentially following the same process as when the component is first created).\\n\\n### Selected Link Style\\n\\nThe final piece is conditionally styling a link based on whether or not it is selected (or the current route).\\n\\n```html\\n<template>\\n  <div>\\n    <router-link class=\\\"parent\\\">\\n      <div :class=\\\"{highlighted: selected}\\\">\\n      </div>\\n    </router-link>\\n\\n    <div v-if=\\\"children !== undefined\\\">\\n      <RecurLink\\n      v-for=\\\"child in path_obj.children\\\" :key=\\\"child.name\\\"\\n      </RecurLink>\\n    </div>\\n  </div>\\n</template>\\n\\n<style>\\n.highlighted {\\n  background-color: purple;\\n}\\n</style>\\n```\\n\\nOne question that comes up is how to update the `selected` data property based on a route change. Simply add a watched property (see more here: [vuejs.org/v2/guide/computed.html#Watchers](https://vuejs.org/v2/guide/computed.html#Watchers)) as such:\\n\\n```js\\nexport default {\\n  watch: {\\n    '$route'() {\\n      this.select_from_path(false)\\n    }\\n  }\\n}\\n```\\n\\nHere we are setting `show_ancestors` to `false` based on the argument so only the state of `selected` gets changed in every RecurLink and ancestors do not get recomputed.\\n\\n## Results\\n\\nHere is a gif showing the behavior of the final version of the NavBar:\\n\\n![final](/assets/projects/personal_site/recursive_navbar/final.gif)\\n\\n## Final Code\\n\\n### RecurNav.vue\\n\\n```html\\n<template>\\n  <keep-alive>\\n    <div class='recur-nav'\\n    @mouseleave=\\\"reset = !reset\\\">\\n      <div>\\n        <RecurLink v-for=\\\"path in paths\\\" :key=\\\"path.name\\\" :path_obj=\\\"path\\\" :reset=\\\"reset\\\" :level=\\\"0\\\"></RecurLink>\\n      </div>\\n    </div>\\n  </keep-alive>\\n</template>\\n\\n<script>\\nimport RecurLink from '@/components/RecurLink.vue'\\n\\nexport default {\\n  components: {\\n    RecurLink\\n  },\\n  data() {\\n    return {\\n      paths: null,\\n      reset: false\\n    }\\n  },  \\n  created () {\\n    this.paths = this.$router.options.routes\\n  },\\n}\\n</script>\\n\\n<style scoped lang=\\\"scss\\\">\\n@import '~@/style/custom';\\n\\n.recur-nav{\\n  @extend .bottom;\\n  @extend .bordered;\\n}\\n</style>\\n```\\n\\n### RecurLink.vue\\n\\n```html\\n<template>\\n  <div>\\n    <div class=\\\"menu-item\\\">\\n    <router-link\\n    v-if=\\\"!(path_obj.nav_show === false)\\\"\\n    :to=\\\"{name: path_obj.name}\\\">\\n      <div v-show=\\\"displayed()\\\"\\n      @mouseover=\\\"hover = true\\\">\\n        <div :class=\\\"{highlighted: selected}\\\">{{path_obj.name}}</div>\\n      </div>\\n    </router-link>\\n    </div>\\n\\n    <div :class=\\\"selected_class()\\\"\\n    v-if=\\\"path_obj.children !== undefined\\\" >\\n      <RecurLink\\n      @show_ancestors=\\\"show_ancestors()\\\"\\n      :show_as_child=\\\"hover\\\"\\n      :reset=\\\"reset\\\"\\n      :level=\\\"level+1\\\"\\n      v-for=\\\"child in path_obj.children\\\" :key=\\\"child.name\\\" :path_obj=\\\"child\\\"></RecurLink>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'RecurLink',\\n  props: {\\n    path_obj: Object,\\n    show_as_child: {type: Boolean, default: false}, // child of hovered link or sibling of hovered link\\n    reset: Boolean,\\n    level: {type: Number, default: -1},\\n  },\\n  data() {\\n    return {\\n      selected: false, // current route\\n      hover: false, // mouseover\\n      ancestor: false, // ancestor of a selected link\\n    }\\n  },\\n  created() { // page reload\\n    this.select_from_path(true)\\n  },\\n  watch: {\\n    reset() {\\n      this.reset_state()\\n    },\\n    '$route'() {\\n      this.select_from_path(false)\\n    }\\n  },\\n  methods: {\\n    reset_state() {\\n      // reset state\\n      this.hover = false\\n      this.ancestor = false\\n\\n      this.select_from_path(true)\\n    },\\n    select_from_path(show_ancestors) {\\n      if (this.$route.name == this.path_obj.name) {\\n        this.selected = true\\n        if (show_ancestors) this.$emit('show_ancestors')\\n      } else {\\n        this.selected = false\\n      }\\n    },\\n    // display all ancestors\\n    show_ancestors() {\\n      this.ancestor = true\\n      this.$emit('show_ancestors')\\n    },\\n    displayed() {\\n      // this.level == 1 displays first level always (since root component is at level 0)\\n      return this.level == 1 || this.selected || this.hover || this.ancestor || this.show_as_child\\n    },\\n    selected_class() {\\n      // this.level !== 0 because the style looks like its applied to the next level elements\\n      if (this.displayed() && this.level !== 0) {\\n        return 'bordered-cell'\\n      } else {\\n        return ''\\n      }\\n    }\\n  }\\n}\\n</script>\\n\\n<style lang=\\\"scss\\\" scoped>\\na {\\n  text-align: left;\\n}\\n.highlighted {\\n  background-color: purple;\\n  display: inline;\\n}\\n.menu-item {\\n  display: flex;\\n}\\n.padded-cell {\\n  padding-left: 3%;\\n  padding-right: 3%;\\n}\\n.bordered-cell {\\n  @extend .padded-cell;\\n  border-left: 1px solid $main-sec-color;\\n  margin-right: -1rem;\\n  padding-right: 1rem;\\n}\\n</style>\\n```\\n\\n### router.js\\n\\n```js\\nconst router = new CustomRouter({\\n  mode: 'history',\\n  base: process.env.BASE_URL,\\n  routes: [\\n    {\\n      path: '/',\\n      name: 'Frame',\\n      component: Frame,\\n      nav_show: false,\\n      children: [\\n        {\\n          path: 'about',\\n          name: 'About Me',\\n          component: TextPage,\\n        },\\n        {\\n          path: 'projects',\\n          name: 'Projects',\\n          component: Projects,\\n          children: [\\n            {\\n              path: 'tetrust',\\n              name: 'Tetrust',\\n              component: Tetrust,\\n              children: [\\n                {\\n                  path: 'commentary',\\n                  name: 'Tetrust Commentary',\\n                },\\n              ]\\n            },\\n            {\\n              path: 'personal_site',\\n              name: 'Personal Site',\\n              component: Project,\\n            }\\n          ]\\n        }\\n      ]\\n    },\\n  ],\\n})\\n```\\n\""],"sourceRoot":""}